##### 初级排序算法
```
选择排序(Selection Sort) --"该放哪个数了?"
每次从未排序数据中找最小值,放到已排序序列的末尾

插入排序(Insertion Sort) --"这个数该放哪儿?"
从前到后依次考虑未排序数据,在已排序序列中找到合适位置插入

冒泡排序(Bubble Sort)
不断循环扫描,每次查看相邻的元素,如果逆序,则交换

平均时间复杂度均为O(N*N)
```

##### 堆排序
```
堆排序(Heap Sort)是对选择排序的优化--利用二叉堆高效地选出最小值
建立一个包含N个元素的二叉堆
重复N次从堆中取出最小值,即可得到有序序列
时间复杂度O(NlogN)

分为建堆和排序2个过程：

建堆有2种思路：
第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。
第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。从非叶子结点开始堆化。

排序的过程，有点类似于"删除堆顶元素",
当堆顶元素移除之后，我们把下标为 n-1的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆
```

##### 希尔排序
```
希尔排序(Shell Sort) 是对插入排序的优化--增量分组插入排序
希尔排序的时间复杂度取决于增量序列（步长序列）的选取
```

##### 归并排序
```
归并排序（Merge Sort）是一个基于分治的算法
时间复杂度O(NlogN)

原问题:把数据排序
子问题:把数据的前一半、后一半分别排序
然后再合并左右两半（两个有序数据）就可以了
```

##### 快速排序
```
快速排序（Quick Sort）也是一个基于分治的算法
 从数组中选取中轴元素pivot
 将小元素放在pivot左边,大元素放在右边
 然后分别对左边和右边的子数组进行快排

快速排序和归并排序具有相似性,但步骤顺序相反
 归并排序：先排序左右子数组,然后合并两个有序数组
 快速排序：先调配出左右子数组,然后对左右子数组分别进行排序
 
随机选取pivot,期望时间复杂度O(NlogN) 
```

##### 非比较类排序
```
计数排序(Counting Sort)
计数排序要求输入的数据必须是有确定范围的数据。将输入的数据作为key存储在额外的数组中,
然后依次把计数大于1的填充回原数组
时间复杂度O(N+M),N为元素个数,M为数值范围

桶排序(Bucket Sort)
桶排序假设输入数据服从均匀分布,将数据分到有限数量的桶里,每个桶再分别排序（有可能使用别的排序算法,或是以递归的方式继续使用桶排序）
时间复杂度 O(N)~O(N*N)

基数排序(Radix Sort)
基数排序把数据切割成一位位数字(0-9),从低到高位对每一位分别进行计数排序
时间复杂度O(NK),K为数字位数
```

##### 排序的稳定性
```
对于序列中存在的若干个关键字相等的元素

如果排序前后它们的相对次序一定保持不变,就称排序算法是稳定的
否则就称排序算法是不稳定的

插入、冒泡、归并、计数、基数和桶排序是稳定的
选择、希尔、快速、堆排序是不稳定的
```

[排序数组](https://leetcode.cn/problems/sort-an-array/description/)<br/>
[数组的相对排序](https://leetcode.cn/problems/relative-sort-array/)<br/>
```
比较类排序
 利用哈希表arr2建立数值到索引的映射
 自定义比较函数

非比较类排序
 计数排序
 第一遍把计数数组中出现在arr2的数值填充回arr1
 第二遍把剩下的填充回arr1
```
[合并区间](https://leetcode.cn/problems/merge-intervals/description/)<br/>
```
方法一:对区间进行双关键字排序(左右端点)
然后扫描合并(排序后能合并的区间一定是连续的)

方法二:差分思想、关键事件思想
把每个区间[l,r] 看作一次+1的覆盖,进行转化为"l处+1"、"r+1处-1"两个事件
把2n个事件排序、扫描,用一个计数变量记录覆盖次数,0变1、1变0时就找到了合并后的区间端点
```
[数组中的第K大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)<br/>
[货仓选址](https://www.acwing.com/problem/content/description/106/)<br/>
```
在一条数轴上有 N家商店，它们的坐标分别为 A1∼AN。
现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。
为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。
1≤N≤100000
```
[翻转对](https://leetcode-cn.com/problems/reverse-pairs/)<br/>
[交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)<br/>
```
在一个数组中统计满足特定大小关系的pair数量,可以考虑基于归并排序求解
```

##### 搜索
```
搜索就是采用直接遍历整个状态空间的方式寻找答案的一类算法
根据遍历状态空间(图)方式的不同,可分为:
 深度优先搜索(DFS,depth first search)
 广度优先搜索(BFS,breadth first search)
 
一般来说,每个状态只遍历一次
所以当状态空间是"图"而不是"树"时,要判重(记忆化) 
```

[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)<br/>
[N皇后](https://leetcode.cn/problems/n-queens/description/)<br/>
[岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)<br/>
```
特征:地图类DFS/BFS,判重、方向数组
```
[最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/description/)<br/>
```
特征:求最小步数,一般用BFS(层次搜索,一层=一步)
把基因序列看成点,变化一次产生一条边,问题就等价于广搜求层数
```
[矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/)<br/>
```
BFS 从0度点作为起点出发，走一步 + 1, dist 记录的从起点出发到dist 这个终点最长的长度    起->终(当前点) 自顶向下 
DFS  dis[x][y] 表示从终点到当前这个起点 最长的长度     终->起（当前点） 自底向上 
```

##### DFS vs BFS
```
DFS更适合搜索树形状态空间
 递归本身就会产生树的结构
 可以用一个全局变量维护状态中较为复杂的信息（例:子集方案、排列方案）
 不需要队列,节省空间

求"最小代价"、"最小步数"的题目,用BFS
 BFS是按层次搜索,第k步搜完才会搜k + 1步,在任意时刻队列中至多只有两层
 
状态空间为有向无环图
 BFS拓扑排序/DFS记忆化搜索均可   
```
